<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H5 图片缩放与着色器工具</title>
    <style>
        :root {
            --border-color: #444;
            --background-color: #222;
            --text-color: #eee;
            --highlight-color: #0a84ff;
            --panel-background: #333;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        .main-container {
            display: flex;
            flex-grow: 1;
            height: calc(100vh - 50px);
        }
        header {
            padding: 10px 20px;
            background: var(--panel-background);
            border-bottom: 1px solid var(--border-color);
            font-size: 1.2em;
            text-align: center;
            height: 30px;
            line-height: 30px;
        }
        .panel {
            padding: 15px;
            box-sizing: border-box;
        }
        .left-panel {
            width: 250px;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }
        .center-panel {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image:
                    linear-gradient(45deg, #404040 25%, transparent 25%),
                    linear-gradient(-45deg, #404040 25%, transparent 25%),
                    linear-gradient(45deg, transparent 75%, #404040 75%),
                    linear-gradient(-45deg, transparent 75%, #404040 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            overflow: auto;
        }
        .right-panel {
            width: 350px;
            border-left: 1px solid var(--border-color);
            overflow-y: auto;
        }
        #drop-zone {
            height: 150px;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            margin-bottom: 15px;
            transition: background-color 0.2s, border-color 0.2s;
        }
        #drop-zone.dragover {
            border-color: var(--highlight-color);
            background-color: rgba(10, 132, 255, 0.1);
        }
        #image-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            flex-grow: 1;
        }
        #image-list li {
            padding: 8px;
            display: flex;
            align-items: center;
            cursor: pointer;
            border-radius: 4px;
            border: 1px solid transparent;
        }
        #image-list li:hover {
            background-color: var(--panel-background);
        }
        #image-list li.selected {
            background-color: rgba(10, 132, 255, 0.2);
            border-color: var(--highlight-color);
        }
        #image-list img {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            object-fit: contain;
        }
        #preview-canvas {
            border: 1px solid var(--border-color);
            background-color: transparent;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .input-pair {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        input[type="number"], select, textarea, button {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            background-color: #2a2a2a;
            color: var(--text-color);
            border: 1px solid #555;
            border-radius: 4px;
        }
        textarea {
            height: 150px;
            font-family: monospace;
            resize: vertical;
        }
        button {
            background-color: var(--highlight-color);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0a78e0;
        }
        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
    </style>
</head>
<body>

<header>H5 图片缩放与着色器工具</header>
<div class="main-container">
    <div class="panel left-panel">
        <div id="drop-zone">
            <p>拖拽 PNG 图片到这里</p>
        </div>
        <ul id="image-list"></ul>
    </div>

    <div class="panel center-panel">
        <canvas id="preview-canvas"></canvas>
    </div>

    <div class="panel right-panel">
        <div class="control-group">
            <label>画布尺寸 (px)</label>
            <div class="input-pair">
                <input type="number" id="canvas-width" value="512" placeholder="宽度">
                <input type="number" id="canvas-height" value="512" placeholder="高度">
            </div>
        </div>
        <div class="control-group">
            <label for="shader-preset">预设着色器</label>
            <select id="shader-preset"></select>
        </div>
        <div class="control-group">
            <div class="btn-group">
                <button id="export-current">导出当前图片</button>
                <button id="export-all">批量导出 (.zip)</button>
            </div>
        </div>
        <div class="control-group">
            <label for="vertex-shader">顶点着色器 (Vertex Shader)</label>
            <textarea id="vertex-shader"></textarea>
        </div>
        <div class="control-group">
            <label for="fragment-shader">片段着色器 (Fragment Shader)</label>
            <textarea id="fragment-shader"></textarea>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const App = {
            dom: {
                dropZone: document.getElementById('drop-zone'),
                imageList: document.getElementById('image-list'),
                previewCanvas: document.getElementById('preview-canvas'),
                canvasWidthInput: document.getElementById('canvas-width'),
                canvasHeightInput: document.getElementById('canvas-height'),
                shaderPresetSelect: document.getElementById('shader-preset'),
                vertexShaderText: document.getElementById('vertex-shader'),
                fragmentShaderText: document.getElementById('fragment-shader'),
                exportCurrentBtn: document.getElementById('export-current'),
                exportAllBtn: document.getElementById('export-all'),
            },

            state: {
                images: [],
                selectedImageId: null,
                gl: null,
                glProgram: null,
                glBuffers: {},
            },

            shaders: {
                default: {
                    v: `
                    attribute vec2 a_position;
                    attribute vec2 a_texCoord;
                    uniform vec2 u_scale;
                    uniform vec2 u_texCoord_scale;

                    varying vec2 v_texCoord;

                    void main() {
                        gl_Position = vec4(a_position * u_scale, 0.0, 1.0);
                        v_texCoord = a_texCoord * u_texCoord_scale;
                    }
                `,
                    f: `
                    precision mediump float;
                    varying vec2 v_texCoord;
                    uniform sampler2D u_texture;
                    void main() {
                        gl_FragColor = texture2D(u_texture, v_texCoord);
                    }
                `
                },
                grayscale: {
                    f: `
                    precision mediump float;
                    varying vec2 v_texCoord;
                    uniform sampler2D u_texture;
                    void main() {
                        vec4 color = texture2D(u_texture, v_texCoord);
                        float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                        gl_FragColor = vec4(vec3(gray), color.a);
                    }
                `
                },
                sepia: {
                    f: `
                    precision mediump float;
                    varying vec2 v_texCoord;
                    uniform sampler2D u_texture;
                    void main() {
                        vec4 color = texture2D(u_texture, v_texCoord);
                        float r = color.r * 0.393 + color.g * 0.769 + color.b * 0.189;
                        float g = color.r * 0.349 + color.g * 0.686 + color.b * 0.168;
                        float b = color.r * 0.272 + color.g * 0.534 + color.b * 0.131;
                        gl_FragColor = vec4(r, g, b, color.a);
                    }
                `
                },
                invert: {
                    f: `
                    precision mediump float;
                    varying vec2 v_texCoord;
                    uniform sampler2D u_texture;
                    void main() {
                        vec4 color = texture2D(u_texture, v_texCoord);
                        gl_FragColor = vec4(1.0 - color.rgb, color.a);
                    }
                `
                },
                pixelate: {
                    f: `
                    precision mediump float;
                    varying vec2 v_texCoord;
                    uniform sampler2D u_texture;
                    uniform vec2 u_resolution;

                    void main() {
                        float pixelSize = 10.0;
                        vec2 step = pixelSize / u_resolution;
                        vec2 coord = floor(v_texCoord / step) * step;
                        gl_FragColor = texture2D(u_texture, coord);
                    }
                `
                }
            },

            init() {
                this.initWebGL();
                this.populateShaderPresets();
                this.updateShaders();
                this.bindEvents();
            },

            initWebGL() {
                const gl = this.dom.previewCanvas.getContext('webgl', { preserveDrawingBuffer: true });
                if (!gl) {
                    alert('WebGL not supported!');
                    return;
                }
                this.state.gl = gl;

                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

                const texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    0, 1,
                    1, 1,
                    0, 0,
                    1, 0
                ]), gl.STATIC_DRAW);

                this.state.glBuffers = { position: positionBuffer, texCoord: texCoordBuffer };
            },

            populateShaderPresets() {
                for (const name in this.shaders) {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name.charAt(0).toUpperCase() + name.slice(1);
                    this.dom.shaderPresetSelect.appendChild(option);
                }
                this.dom.vertexShaderText.value = this.shaders.default.v;
                this.dom.fragmentShaderText.value = this.shaders.default.f;
            },

            bindEvents() {
                const dom = this.dom;
                dom.dropZone.addEventListener('dragover', e => {
                    e.preventDefault();
                    dom.dropZone.classList.add('dragover');
                });
                dom.dropZone.addEventListener('dragleave', () => dom.dropZone.classList.remove('dragover'));
                dom.dropZone.addEventListener('drop', e => {
                    e.preventDefault();
                    dom.dropZone.classList.remove('dragover');
                    this.handleFiles(e.dataTransfer.files);
                });

                dom.canvasWidthInput.addEventListener('change', () => this.renderSelectedImage());
                dom.canvasHeightInput.addEventListener('change', () => this.renderSelectedImage());

                dom.shaderPresetSelect.addEventListener('change', e => {
                    const preset = this.shaders[e.target.value];
                    if (preset) {
                        this.dom.vertexShaderText.value = preset.v || this.shaders.default.v;
                        this.dom.fragmentShaderText.value = preset.f || this.shaders.default.f;
                        this.updateShadersAndRender();
                    }
                });
                dom.vertexShaderText.addEventListener('input', () => this.updateShadersAndRender());
                dom.fragmentShaderText.addEventListener('input', () => this.updateShadersAndRender());
                dom.exportCurrentBtn.addEventListener('click', () => this.exportCurrentImage());
                dom.exportAllBtn.addEventListener('click', () => this.exportAllImages());
            },

            async handleFiles(files) {
                const pngFiles = Array.from(files).filter(file => file.type === 'image/png');
                for (const file of pngFiles) {
                    const id = Date.now() + Math.random();
                    const dataUrl = await this.readFileAsDataURL(file);
                    const newImage = { id, file, name: file.name, dataUrl };

                    this.state.images.push(newImage);
                    this.addImageToList(newImage);

                    this.processImage(newImage);
                }
            },

            readFileAsDataURL(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            },

            addImageToList(image) {
                const li = document.createElement('li');
                li.dataset.id = image.id;
                li.innerHTML = `<img src="${image.dataUrl}" alt="${image.name}"><span>${image.name}</span>`;
                li.addEventListener('click', () => this.selectImage(image.id));
                this.dom.imageList.appendChild(li);
                if(this.state.images.length === 1) {
                    this.selectImage(image.id);
                }
            },

            selectImage(id) {
                this.state.selectedImageId = id;
                document.querySelectorAll('#image-list li').forEach(li => {
                    li.classList.toggle('selected', li.dataset.id == id);
                });
                this.renderSelectedImage();
            },

            async processImage(image) {
                const alphaThreshold = 10;

                const img = new Image();
                img.src = image.dataUrl;
                await new Promise(resolve => img.onload = resolve);

                if (img.width === 0 || img.height === 0) {
                    image.boundingBox = { x: 0, y: 0, width: 0, height: 0 };
                    image.imageBitmap = await createImageBitmap(img, 0, 0, 0, 0);
                    return;
                }

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                tempCtx.drawImage(img, 0, 0);

                const data = tempCtx.getImageData(0, 0, img.width, img.height).data;
                let minX = img.width, minY = img.height, maxX = -1, maxY = -1;

                for (let y = 0; y < img.height; y++) {
                    for (let x = 0; x < img.width; x++) {
                        const alpha = data[(y * img.width + x) * 4 + 3];
                        if (alpha > alphaThreshold) {
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }

                const hasContent = maxX > -1;
                image.boundingBox = hasContent ? {
                    x: minX,
                    y: minY,
                    width: maxX - minX + 1,
                    height: maxY - minY + 1
                } : { x: 0, y: 0, width: img.width, height: img.height };

                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = image.boundingBox.width;
                cropCanvas.height = image.boundingBox.height;
                const cropCtx = cropCanvas.getContext('2d');

                cropCtx.drawImage(
                    img,
                    image.boundingBox.x, image.boundingBox.y,
                    image.boundingBox.width, image.boundingBox.height,
                    0, 0,
                    image.boundingBox.width, image.boundingBox.height
                );

                image.imageBitmap = await createImageBitmap(cropCanvas);
            },

            renderSelectedImage() {
                if (!this.state.selectedImageId) return;
                const image = this.state.images.find(img => img.id === this.state.selectedImageId);
                if (image && image.imageBitmap) {
                    this.renderToCanvas(image.imageBitmap);
                } else if (image) {
                    this.processImage(image).then(() => this.renderToCanvas(image.imageBitmap));
                }
            },

            updateShadersAndRender() {
                if (this.updateShaders()) {
                    this.renderSelectedImage();
                }
            },

            updateShaders() {
                const gl = this.state.gl;
                const vsSource = this.dom.vertexShaderText.value;
                const fsSource = this.dom.fragmentShaderText.value;

                if (!vsSource.trim() || !fsSource.trim()) {
                    console.warn("Shader source is empty. Halting compilation.");
                    return false;
                }

                const vertexShader = this.createShader(gl.VERTEX_SHADER, vsSource);
                const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fsSource);

                if (!vertexShader || !fragmentShader) return false;

                const program = this.createProgram(vertexShader, fragmentShader);
                if (!program) return false;

                if (this.state.glProgram) {
                    gl.deleteProgram(this.state.glProgram);
                }
                this.state.glProgram = program;
                return true;
            },

            createShader(type, source) {
                const gl = this.state.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            },

            createProgram(vertexShader, fragmentShader) {
                const gl = this.state.gl;
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program link error:', gl.getProgramInfoLog(program));
                    gl.deleteProgram(program);
                    return null;
                }
                return program;
            },

            nextPowerOf2(n) {
                if (n > 0 && (n & (n - 1)) === 0) {
                    return n;
                }
                let p = 1;
                while (p < n) {
                    p <<= 1;
                }
                return p;
            },

            renderToCanvas(imageBitmap) {
                const gl = this.state.gl;
                if (!gl || !this.state.glProgram) return;

                const potCanvas = document.createElement('canvas');
                const potCtx = potCanvas.getContext('2d');
                potCanvas.width = this.nextPowerOf2(imageBitmap.width);
                potCanvas.height = this.nextPowerOf2(imageBitmap.height);
                potCtx.drawImage(imageBitmap, 0, 0);

                const targetWidth = parseInt(this.dom.canvasWidthInput.value, 10);
                const targetHeight = parseInt(this.dom.canvasHeightInput.value, 10);

                this.dom.previewCanvas.width = targetWidth;
                this.dom.previewCanvas.height = targetHeight;
                gl.viewport(0, 0, targetWidth, targetHeight);

                gl.useProgram(this.state.glProgram);

                const positionLocation = gl.getAttribLocation(this.state.glProgram, 'a_position');
                gl.enableVertexAttribArray(positionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.state.glBuffers.position);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

                const texCoordLocation = gl.getAttribLocation(this.state.glProgram, 'a_texCoord');
                gl.enableVertexAttribArray(texCoordLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.state.glBuffers.texCoord);
                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);

                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, potCanvas);
                gl.generateMipmap(gl.TEXTURE_2D);

                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                const bb = { width: imageBitmap.width, height: imageBitmap.height };

                const scaleX = targetWidth / bb.width;
                const scaleY = targetHeight / bb.height;
                const scale = Math.min(scaleX, scaleY);

                const newWidth = bb.width * scale;
                const newHeight = bb.height * scale;
                const x_scale = newWidth / targetWidth;
                const y_scale = newHeight / targetHeight;

                const scaleLocation = gl.getUniformLocation(this.state.glProgram, 'u_scale');
                gl.uniform2f(scaleLocation, x_scale, y_scale);

                const texCoordScaleX = imageBitmap.width / potCanvas.width;
                const texCoordScaleY = imageBitmap.height / potCanvas.height;
                const texScaleLocation = gl.getUniformLocation(this.state.glProgram, 'u_texCoord_scale');
                gl.uniform2f(texScaleLocation, texCoordScaleX, texCoordScaleY);

                const resolutionLocation = gl.getUniformLocation(this.state.glProgram, 'u_resolution');
                gl.uniform2f(resolutionLocation, targetWidth, targetHeight);

                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                gl.deleteTexture(texture);
            },

            exportCurrentImage() {
                if (!this.state.selectedImageId) return;
                const image = this.state.images.find(img => img.id === this.state.selectedImageId);

                const a = document.createElement('a');
                a.href = this.dom.previewCanvas.toDataURL('image/png');
                a.download = `processed_${image.name}`;
                a.click();
            },

            async exportAllImages() {
                if (this.state.images.length === 0) return;
                alert('开始批量导出，请稍候...');

                const zip = new JSZip();
                const originalSelectedId = this.state.selectedImageId;

                for (const image of this.state.images) {
                    if (!image.imageBitmap) {
                        await this.processImage(image);
                    }

                    this.selectImage(image.id);

                    await new Promise(res => setTimeout(res, 50));

                    const dataUrl = this.dom.previewCanvas.toDataURL('image/png');
                    const blob = await (await fetch(dataUrl)).blob();

                    zip.file(`processed_${image.name}`, blob);
                }

                if (originalSelectedId) {
                    this.selectImage(originalSelectedId);
                }

                zip.generateAsync({ type: 'blob' }).then(content => {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(content);
                    a.download = 'processed_images.zip';
                    a.click();
                    URL.revokeObjectURL(a.href);
                });
            }
        };

        App.init();
    });
</script>
</body>
</html>
